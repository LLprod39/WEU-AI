# Ralph + Cursor: безотказные таски для написания кода

## Как это работает

**Ralph Wiggum** — техника автономной итерации: один и тот же промпт многократно передаётся агенту (Cursor CLI), пока задача не будет выполнена. Контекст «сбрасывается» между итерациями, прогресс остаётся в файлах и git.

В WEU:

1. **Workflow с runtime `cursor`** — каждый шаг может работать в режиме **Ralph-цикла**:
   - Запускается Cursor CLI (`agent -p --force --output-format stream-json ... --model auto "промпт"`).
   - Если в выводе нет тега `<promise>STEP_DONE</promise>` (или вашего `completion_promise`), шаг повторяется: агент получает **исходную задачу + предыдущий вывод** и снова пишет код.
   - Цикл идёт до появления promise или до `max_iterations` (по умолчанию 10).

2. **Completion promise** — сигнал «задача сделана». В промпт автоматически добавляется:
   - `When complete output exactly: <promise>STEP_DONE</promise>.`
   - Агент должен вывести ровно этот тег, когда код готов. Тогда шаг считается успешным и переходим к следующему.

3. **Повторы при сбоях** — если шаг упал (exit code ≠ 0, Connection stalled, promise не найден после N итераций), срабатывает **retry** (до `max_retries`, по умолчанию 3). Промпт при повторе включает текст ошибки.

## Настройка шага в workflow

В `steps` у каждого шага:

| Поле | По умолчанию | Описание |
|------|--------------|----------|
| `completion_promise` | `STEP_DONE` | Строка внутри `<promise>...</promise>`, по которой считаем шаг выполненным. |
| `max_iterations` | `10` | Сколько раз подряд запускать агента по одному шагу, пока не появится promise. |
| `use_ralph_loop` | `true` | Включить Ralph-цикл (несколько итераций до promise). `false` — один запуск агента. |
| `verify_prompt` | — | Опционально: второй запуск агента с этим промптом для проверки (например, «проверь, что проект собирается»). |
| `verify_promise` | `PASS` | Строка в выводе verify-запуска, по которой проверка считается пройденной. |

Пример шага для надёжного написания кода:

```json
{
  "title": "Создать API",
  "prompt": "Добавь REST API для пользователей: GET/POST /users, валидация, сохранение в БД.",
  "completion_promise": "STEP_DONE",
  "max_iterations": 10,
  "use_ralph_loop": true,
  "verify_prompt": "Запусти тесты и убедись, что API отвечает. Output <promise>PASS</promise> если ок.",
  "verify_promise": "PASS"
}
```

## Рекомендации для безотказных тасков

1. **Чёткая задача в `prompt`** — что именно написать (файлы, эндпоинты, команды запуска). Чем конкретнее, тем стабильнее результат.

2. **Один шаг — одна подзадача** — не «сделай весь бэкенд», а «добавь модель User и миграцию», «добавь POST /login», «добавь тесты для /login».

3. **Используйте `completion_promise`** — всегда задавайте явный сигнал завершения (например `STEP_DONE` или `DONE`) и в промпте пишите, что по завершении нужно вывести ровно `<promise>STEP_DONE</promise>` (это добавляется автоматически).

4. **`max_iterations` 8–12** — для шагов с кодом обычно хватает 10 итераций; при нестабильном API можно поднять до 12–15.

5. **`verify_prompt` для критичных шагов** — например «собери проект и запусти тесты; если всё ок, выведи <promise>PASS</promise>». Тогда при провале verify шаг уйдёт в retry с понятной ошибкой.

6. **Runtime `ralph` в workflow** — в WEU при `runtime: "ralph"` бэкенд по умолчанию `cursor`; шаги выполняются тем же Cursor CLI с Ralph-циклом в каждом шаге (как описано выше). Отдельный бинарник `ralph` не обязателен.

## Ralph vs один запуск

- **Без Ralph** (`use_ralph_loop: false` или `max_iterations: 1`) — один вызов агента на шаг. Быстрее, но при неполном решении шаг «успешен» только если агент всё же вывел promise.
- **С Ralph** (`use_ralph_loop: true`, `max_iterations` > 1) — агент получает несколько попыток с контекстом предыдущего вывода; подходит для шагов «написать и довести до рабочего кода».

## Ссылки

- [Ralph Wiggum technique](https://ghuntley.com/ralph/) — прогресс сохраняется, контекст сбрасывается между итерациями.
- [Ralph Orchestrator](https://github.com/mikeyobrien/ralph-orchestrator) — мульти-бэкенд (Claude, Gemini, Cursor и др.), в WEU используется своя реализация цикла поверх Cursor CLI.
- [Cursor CLI](https://cursor.com/docs/cli/overview) — headless-режим с `-p`, `--force`, `--output-format stream-json`.

# База данных (MVP)

## Зачем PostgreSQL вместо SQLite

SQLite блокирует всю БД при записи. Когда одновременно работают чат, оркестратор, агенты и задачи, возникают задержки и долгая загрузка. PostgreSQL обрабатывает много параллельных подключений без таких блокировок и подходит для MVP при нескольких пользователях и активных агентах.

## Варианты запуска

### 1. PostgreSQL через Docker (рекомендуется для MVP)

Поднимите контейнер:

```bash
docker compose up -d postgres
```

В `.env` задайте параметры (или используйте значения по умолчанию из `docker-compose.yml`):

```env
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=weu_platform
POSTGRES_USER=weu
POSTGRES_PASSWORD=weu_secret_change_me
```

Минимально достаточно указать:

```env
POSTGRES_HOST=localhost
POSTGRES_PASSWORD=weu_secret_change_me
```

Остальное подхватится из значений по умолчанию в `docker-compose.yml`.

Потом:

```bash
python manage.py migrate
python manage.py createsuperuser
python manage.py runserver
```

### 2. Только SQLite (без Docker)

Если не задавать `POSTGRES_HOST` и `POSTGRES_DB`, Django использует `db.sqlite3` в корне проекта. Удобно для быстрого локального старта, но при активной работе агентов и нескольких вкладках возможны тормоза.

### 3. Внешний PostgreSQL

Укажите в `.env` хост и данные существующей инсталляции:

```env
POSTGRES_HOST=your-db-host
POSTGRES_PORT=5432
POSTGRES_DB=weu_platform
POSTGRES_USER=weu
POSTGRES_PASSWORD=your_password
```

## Структура данных

Все данные хранятся в одной БД. Таблицы логически разнесены по приложениям:

| Приложение  | Назначение                          |
|-------------|-------------------------------------|
| auth, sessions, contenttypes, admin | Пользователи, сессии, админка |
| agent_hub   | Профили агентов, пресеты, воркфлоу, запуски |
| tasks       | Задачи, подзадачи, метки, комментарии, исполнения |
| servers     | Серверы, группы, история команд      |
| passwords   | Учётные записи и категории (пароли шифруются) |

Индексы уже заданы в моделях по полям, по которым идёт фильтрация и сортировка (владелец, статус, даты и т.п.), поэтому запросы при росте данных остаются быстрыми.

## Параметры соединения (Django)

При использовании PostgreSQL в настройках включено:

- **CONN_MAX_AGE=60** — переиспользование соединений внутри процесса, меньше открытий/закрытий под нагрузкой.
- **statement_timeout=30s** — запросы дольше 30 секунд обрываются, чтобы не блокировать воркеры.

Для ещё большей нагрузки позже можно добавить PgBouncer и вынести пул соединений в отдельный слой.

## Миграции

Миграции общие для SQLite и PostgreSQL. После перехода с SQLite на PostgreSQL выполните:

```bash
python manage.py migrate
```

Данные из SQLite переносятся вручную (dump/restore или экспорт/импорт через скрипты), если нужно сохранить старую базу.
